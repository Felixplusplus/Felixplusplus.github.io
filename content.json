{"meta":{"title":"匀昊的旧笔记","subtitle":"天下事有难易乎？为之，则难者亦易也","description":null,"author":"匀昊","url":"https://felixplusplus.github.io"},"pages":[{"title":"categories","date":"2018-08-18T16:41:15.000Z","updated":"2018-08-18T16:41:35.347Z","comments":true,"path":"categories/index.html","permalink":"https://felixplusplus.github.io/categories/index.html","excerpt":"","text":""},{"title":"FELIX 's RESUME","date":"2018-08-18T16:43:18.000Z","updated":"2018-08-18T17:40:19.392Z","comments":true,"path":"about/index.html","permalink":"https://felixplusplus.github.io/about/index.html","excerpt":"","text":"Who Am IBase Info 姓名 : 张云皓 籍贯 : 黑龙江 生日 : 1993.xx.xx 院校 : 哈尔滨理工大学 专业 : 软件工程 邮箱 : zyhzhangyunhao@gmail.com Education Experience 2012年9月~2016年6月 哈尔滨理工大学软件工程 2012年9月~2016年6月 哈尔滨理工大学会计 Work Experience 2016年11月~2016年9月 北京神州绿盟科技有限公司 安全工程师 2016年10月~ 杭州迪火科技有限公司 iOS高级开发工程师 What Have I Done What Can I Do"},{"title":"Tagcloud","date":"2017-04-26T09:47:43.000Z","updated":"2018-08-18T11:07:17.135Z","comments":true,"path":"tags/index.html","permalink":"https://felixplusplus.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"大话lldb","slug":"lldb","date":"2018-08-27T07:06:47.000Z","updated":"2018-08-28T05:37:26.222Z","comments":true,"path":"2018/08/27/lldb/","link":"","permalink":"https://felixplusplus.github.io/2018/08/27/lldb/","excerpt":"","text":"lldb 简介lldb 是什么lldb 是我们日常开发用来调试的命令行工具 Usage进阶Chisel总结","categories":[],"tags":[]},{"title":"使用swift搭建简易区块链并实现使用webApi进行调度","slug":"swiftBlockChain","date":"2018-08-11T03:28:28.000Z","updated":"2018-08-18T10:52:16.949Z","comments":true,"path":"2018/08/11/swiftBlockChain/","link":"","permalink":"https://felixplusplus.github.io/2018/08/11/swiftBlockChain/","excerpt":"","text":"Reason最近特别好奇比特币为啥那么贵 ， 那么多人去炒 ， 所以先了解一下区块链 ， 并使用swift实现一个练练手 源码地址 BlockChain 所谓区块链技术 ， 简称BT（Blockchain technology），也被称之为分布式账本技术，是一种互联网数据库技术，其特点是去中心化、公开透明，让每个人均可参与数据库记录。 Base 交易（Transaction）：一次操作，导致账本状态的一次改变，如添加一条记录； 区块（Block）：记录一段时间内发生的交易和状态结果，是对当前账本状态的一次共识； 链（Chain）：由一个个区块按照发生顺序串联而成，是整个状态变化的日志记录。 如果把区块链作为一个状态机，则每次交易就是试图改变一次状态，而每次共识生成的区块，就是参与者对于区块中所有交易内容导致状态改变的结果进行确认。 阐述 用通俗的话阐述：如果我们把数据库假设成一本账本，读写数据库就可以看做一种记账的行为，区块链技术的原理就是在一段时间内找出记账最快最好的人，由这个人来记账，然后将账本的这一页信息发给整个系统里的其他所有人。这也就相当于改变数据库所有的记录，发给全网的其他每个节点，所以区块链技术也称为分布式账本（distributed ledger）。 Vapor既然要用swift实现 ， 我在这里就选择vapor作为服务端框架来使用 ， vapor里面有意思的东西很多 ， 这里只介绍基本的操作而不深究其原理 。 Install前置条件 ， 这里我们使用macOS进行开发部署 ， 以下是需要软件和版本。 Install Xcode 9.3 or greater from the Mac App Store. Vapor requires Swift 4.1 or greater. Vapor Toolbox: 3.1.7 Vapor Framework: 3.0.8 homeBrew 接着使用homeBrew安装 1brew install vapor/tap/vapor Get Started现在vapor已经装好了 ， 我们可以先把基本的准备工作弄好 使用vapor初始化工程 1vapor new blockChainServer 生成工程文件 1vapor xcode 接着打开 blockChainServer.xcodeproj 文件 ， 在导航上的schema上选择 run ，接着按下 command + R 这时你应能够在控制台看到输出的server地址了 Practice到现在我们一切准备工作都就绪了 ， 那么开始鼓捣个区块链api出来吧 。 Base model区块链的基本概念上面介绍了 ， 包含以下几类 ， 我们使用oop可以抽象出以下一堆class Transaction 交易 Block 区块 Blockchain 区块链 BlockChainNode 区块链节点 排列由下向上存在集合关系 。 其实这里面最后应该加上一个区块网络 ， 不过这里我们暂时不需要实现全部网络 ， 搞个内网的先耍耍就好 下面分别来看下几个model的代码 ps:这里的框架添加的协议和扩展很多 ， 不在此过多介绍 ， 请把关注点放在class本身 Transaction.swift 12345678910111213141516171819202122import Foundationimport FluentSQLiteimport Vaporfinal class Transaction: Codable,SQLiteModel &#123; var id: Int? var from: String var to: String var amount: Double init(from: String, to: String, amount: Double) &#123; self.from = from self.to = to self.amount = amount &#125;&#125;extension Transaction: Content &#123; &#125;extension Transaction: Migration &#123; &#125;extension Transaction: Parameter &#123; &#125; 这里我们可以看到定义了几个property ， id是SQLiteModel协议需要实现的 ， 这里只要记住是为了数据持久化就好 to : 交易的接收方 from : 交易的发起方 amount : 金额 Block.swift 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import FluentSQLiteimport Vaporfinal class Block: Codable,SQLiteModel &#123; var id: Int? var index: Int = 0 var dateCreated: String var previousHash: String! var hash: String! var nonce: Int var message: String = \"\" private (set) var transactions: [Transaction] = [Transaction]() var key: String &#123; get &#123; let transactionsData = try! JSONEncoder().encode(transactions) let transactionsJSONString = String(data: transactionsData, encoding: .utf8) return String(index) + dateCreated + previousHash + transactionsJSONString! + String(nonce) &#125; &#125; @discardableResult func addTransaction(transaction: Transaction) -&gt; Block&#123; transactions.append(transaction) return self &#125; init() &#123; dateCreated = Date().toString() nonce = 0 message = \"挖出新的区块\" &#125; init(transaction: Transaction) &#123; dateCreated = Date().toString() nonce = 0 addTransaction(transaction: transaction) &#125;&#125;extension Block: Content &#123; &#125;extension Block: Migration &#123; &#125;extension Block: Parameter &#123; &#125; index : 区块序号 dateCreated : 创建日期 previousHash : 前一个区块的哈希值 hash : 当前区块的哈希值 nonce : 先记住和工作量证明有关 message : 这里是为了我们看到输出 Blockchain.swift 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import Foundationimport FluentSQLiteimport Vaporfinal class Blockchain: Codable,SQLiteModel &#123; var id: Int? var blocks: [Block] = [Block]() init() &#123; &#125; init(_ genesisBlock: Block) &#123; self.addBlock(genesisBlock) &#125; func addBlock(_ block: Block) &#123; if self.blocks.isEmpty &#123; // 添加创世区块 // 第一个区块没有 previous hash block.previousHash = \"0\" &#125; else &#123; let previousBlock = getPreviousBlock() block.previousHash = previousBlock.hash block.index = self.blocks.count &#125; block.hash = generateHash(for: block) self.blocks.append(block) block.message = \"此区块已添加至区块链\" &#125; private func getPreviousBlock() -&gt; Block &#123; return self.blocks[self.blocks.count - 1] &#125; private func displayBlock(_ block: Block) &#123; print(\"------ 第 \\(block.index) 个区块 --------\") print(\"创建日期：\\(block.dateCreated)\") // print(\"数据：\\(block.data)\") print(\"Nonce：\\(block.nonce)\") print(\"前一个区块的哈希值：\\(block.previousHash!)\") print(\"哈希值：\\(block.hash!)\") &#125; private func generateHash(for block: Block) -&gt; String &#123; var hash = block.key.sha1Hash() // 设置工作量证明 while(!hash.hasPrefix(\"11\")) &#123; block.nonce += 1 hash = block.key.sha1Hash() print(hash) &#125; return hash &#125;&#125;extension Blockchain: Content &#123; &#125;extension Blockchain: Migration &#123; &#125;extension Blockchain: Parameter &#123; &#125; BlockChainNode.swift 1234567891011121314151617import FluentSQLiteimport Vaporfinal class BlockChainNode: Codable,SQLiteModel &#123; var id: Int? var address :String init(addr:String) &#123; address = addr &#125;&#125;extension BlockChainNode: Content &#123; &#125;extension BlockChainNode: Migration &#123; &#125;extension BlockChainNode: Parameter &#123; &#125; address : 节点地址 Action这里涉及到的事件主要是计算hash ， 我们在这里面给String 添加一个extension 12345678910111213141516171819202122extension String &#123; func sha1Hash() -&gt; String &#123; let task = Process() task.launchPath = \"/usr/bin/shasum\" task.arguments = [] let inputPipe = Pipe() inputPipe.fileHandleForWriting.write(self.data(using: .utf8)!) inputPipe.fileHandleForWriting.closeFile() let outputPipe = Pipe() task.standardOutput = outputPipe task.standardInput = inputPipe task.launch() let data = outputPipe.fileHandleForReading.readDataToEndOfFile() let hash = String(data: data, encoding: .utf8)! return hash.replacingOccurrences(of: \" -\\n\", with: \"\") &#125;&#125; 给date也添加一个便于我们输出区块创建时间 1234567extension Date &#123; func toString() -&gt; String &#123; let formatter = DateFormatter() formatter.dateFormat = \"yyyy-MM-dd HH:mm:ss\" return formatter.string(from: self) &#125;&#125; Service在这里我们把所有对区块链的操作抽象为一个service类 BlockchainService.swift 1234567891011121314151617181920212223242526272829303132333435363738import Foundationimport Vaporclass BlockchainService &#123; private var blockchain: Blockchain = Blockchain() private var nodes = [BlockChainNode]() init() &#123; &#125; func addBlock(_ block: Block) -&gt; Block &#123; self.blockchain.addBlock(block) return block &#125; func getLastBlock() -&gt; Block &#123; guard let lastB = self.blockchain.blocks.last else &#123; return addBlock(Block()) &#125; return lastB; &#125; func getBlockchain() -&gt; Blockchain &#123; return self.blockchain &#125; func registerNode(_ node:BlockChainNode) -&gt; BlockChainNode &#123; self.nodes.append(node) return node &#125; func getAllNodes() -&gt; [BlockChainNode] &#123; return nodes &#125;&#125; Controller &amp; Router这里我们基本完成了所有基本模型的搭建 ， 现在需要对我们的server进行操作 ， 让我们可以方便的通过curl调用我们的区块链系统 。 BlockChainController.swift 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import Foundationimport Vaporstruct BCError:LocalizedError &#123; let name:String&#125;final class BlockChainController &#123; let bcService = BlockchainService() func addBlock(_ req: Request) throws -&gt; Future&lt;Block&gt; &#123; return bcService.addBlock(Block()).save(on: req) &#125; func addTransaction(_ req: Request) throws -&gt; Future&lt;Block&gt; &#123; return try req.content.decode(Transaction.self).flatMap&#123; transation in return self.bcService.getLastBlock().addTransaction(transaction: transation).save(on: req) &#125; &#125; func findBlockChain(_ req: Request) throws -&gt; Future&lt;Blockchain&gt; &#123; return bcService.getBlockchain().save(on: req) &#125; func registeNode(_ req: Request) throws -&gt; Future&lt;BlockChainNode&gt; &#123; return try req.content.decode(BlockChainNode.self).flatMap&#123; node in return self.bcService.registerNode(node).save(on: req) &#125; &#125; func allNodes(_ req: Request) throws -&gt; Future&lt;[BlockChainNode]&gt; &#123; return BlockChainNode.query(on: req).all() &#125; func resolve(_ req: Request) throws -&gt; Future&lt;Blockchain&gt; &#123; let promise = req.eventLoop.newPromise(Blockchain.self) bcService.getAllNodes().forEach &#123; node in guard let url = URL(string: \"http://\\(node.address)/blockchain\") else &#123;return promise.fail(error: BCError(name: \"node error\"))&#125; URLSession.shared.dataTask(with: url, completionHandler: &#123; (data, _, _) in if let data = data &#123; guard let bc = try? JSONDecoder().decode(Blockchain.self, from: data) else &#123;return promise.fail(error: BCError(name: \"json error\"))&#125; if self.bcService.getBlockchain().blocks.count &lt; bc.blocks.count &#123; self.bcService.getBlockchain().blocks = bc.blocks &#125; promise.succeed(result: self.bcService.getBlockchain()) &#125; else &#123; promise.fail(error: BCError(name: \"data Error\")) &#125; &#125;).resume() &#125; return promise.futureResult &#125;&#125; routes.swift 1234567891011121314151617import Vapor/// Register your application's routes here.public func routes(_ router: Router) throws &#123; // Basic \"Hello, world!\" example router.get(\"hello\") &#123; req in return \"Hello, world!\" &#125; let bcc = BlockChainController() router.post(\"block\", use: bcc.addBlock) router.post(\"transaction\", use: bcc.addTransaction) router.get(\"blockchain\", use: bcc.findBlockChain) router.post(\"node\", use: bcc.registeNode) router.get(\"node\", use: bcc.allNodes) router.post(\"resolve\", use: bcc.resolve)&#125; 现在解释一下我们注册的api都是干啥的 ps:API层遵守restfull post(“block”, use: bcc.addBlock) 增加一个区块 post(“transaction”, use: bcc.addTransaction) 新增一笔交易 get(“blockchain”, use: bcc.findBlockChain) 查询区块链 post(“node”, use: bcc.registeNode) 增加节点 get(“node”, use: bcc.allNodes) 获取全部节点 post(“resolve”, use: bcc.resolve) 解决冲突 Example下面我们可以让服务运行起来 ， 然后通过curl命令行来调用区块链系统 ， 编译工程进入我们的工程目录 ， 执行命令 1vapor build 你应能看到以下输出 1Building Project [Done] 这说明我们的工程可以运行了 运行工程1vapor run serve --port=8080 我们在本地8080端口上开启我们的服务 这时应能看到如下输出 123456789Running blockChainServer ...[ INFO ] Migrating 'sqlite' database (/Users/felix/Documents/TestFolder/blockChainServer/.build/checkouts/fluent.git-6251908308727715749/Sources/Fluent/Migration/MigrationConfig.swift:69)[ INFO ] Preparing migration 'Todo' (/Users/felix/Documents/TestFolder/blockChainServer/.build/checkouts/fluent.git-6251908308727715749/Sources/Fluent/Migration/Migrations.swift:111)[ INFO ] Preparing migration 'Block' (/Users/felix/Documents/TestFolder/blockChainServer/.build/checkouts/fluent.git-6251908308727715749/Sources/Fluent/Migration/Migrations.swift:111)[ INFO ] Preparing migration 'Blockchain' (/Users/felix/Documents/TestFolder/blockChainServer/.build/checkouts/fluent.git-6251908308727715749/Sources/Fluent/Migration/Migrations.swift:111)[ INFO ] Preparing migration 'BlockChainNode' (/Users/felix/Documents/TestFolder/blockChainServer/.build/checkouts/fluent.git-6251908308727715749/Sources/Fluent/Migration/Migrations.swift:111)[ INFO ] Migrations complete (/Users/felix/Documents/TestFolder/blockChainServer/.build/checkouts/fluent.git-6251908308727715749/Sources/Fluent/Migration/MigrationConfig.swift:73)[Deprecated] --option=value syntax is deprecated. Please use --option value (with no =) instead.Server starting on http://localhost:8080 现在我们只要用api调用以下 ， 本机的区块链系统就会响应了 ， 让我们试一下吧 创建区块1curl -s -X POST localhost:8080/block 你会在一段时间后看到响应 12345678910&#123; \"dateCreated\": \"2018-08-11 17:19:01\", \"hash\": \"1124aa2a5867abee8b9cc3a3f4051b6665f89e26\", \"id\": 1, \"index\": 0, \"message\": \"\\u6b64\\u533a\\u5757\\u5df2\\u6dfb\\u52a0\\u81f3\\u533a\\u5757\\u94fe\", \"nonce\": 193, \"previousHash\": \"0\", \"transactions\": []&#125; 我们的第一个block已经创建成功并且被加入区块链里了 ， 他的previousHash为“0”是因为他是创世区块 。 添加交易我们可以在这里添加几笔交易看看 1curl -s -X POST localhost:8080/transaction --data \"from=Felix&amp;to=mayun&amp;amount=100\" | python -m json.tool data里面表示 Felix向mayun转账100 每次添加后你将会得到区块的最新信息 12345678910111213141516&#123; \"dateCreated\": \"2018-08-11 17:19:01\", \"hash\": \"1124aa2a5867abee8b9cc3a3f4051b6665f89e26\", \"id\": 1, \"index\": 0, \"message\": \"\\u6b64\\u533a\\u5757\\u5df2\\u6dfb\\u52a0\\u81f3\\u533a\\u5757\\u94fe\", \"nonce\": 193, \"previousHash\": \"0\", \"transactions\": [ &#123; \"amount\": 100, \"from\": \"Felix\", \"to\": \"mayun\" &#125; ]&#125; 查询链我们可以重复以上操作几次 。 然后查看整个区块链信息 1curl -s -X GET localhost:8080/blockchain | python -m json.tool 你会看到蕾丝如下输出 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&#123; \"blocks\": [ &#123; \"dateCreated\": \"2018-08-11 17:19:01\", \"hash\": \"1124aa2a5867abee8b9cc3a3f4051b6665f89e26\", \"id\": 1, \"index\": 0, \"message\": \"\\u6b64\\u533a\\u5757\\u5df2\\u6dfb\\u52a0\\u81f3\\u533a\\u5757\\u94fe\", \"nonce\": 193, \"previousHash\": \"0\", \"transactions\": [ &#123; \"amount\": 100, \"from\": \"Felix\", \"to\": \"mayun\" &#125;, &#123; \"amount\": 100, \"from\": \"Felix\", \"to\": \"mayun\" &#125; ] &#125;, &#123; \"dateCreated\": \"2018-08-11 17:27:39\", \"hash\": \"11bec5f7bf8226c62119adfbb03ad37d24267092\", \"id\": 2, \"index\": 1, \"message\": \"\\u6b64\\u533a\\u5757\\u5df2\\u6dfb\\u52a0\\u81f3\\u533a\\u5757\\u94fe\", \"nonce\": 277, \"previousHash\": \"1124aa2a5867abee8b9cc3a3f4051b6665f89e26\", \"transactions\": [ &#123; \"amount\": 100, \"from\": \"Felix\", \"to\": \"mayun\" &#125;, &#123; \"amount\": 100, \"from\": \"Felix\", \"to\": \"mayun\" &#125; ] &#125; ], \"id\": 1&#125; 我们可以看到Felix不停的向mayun转100块 ， 真不要脸 。 节点以及解决冲突区块链同时存在与多个主机上 ， 也就是说会有很多的block-chain-server运行 ， 而对于不同的运算会有多个解产生 ， 这就是冲突问题了 ， 那么我们看下冲突解决的过程吧 首先 ， 我们在8081端口同时开启一个服务 1vapor run serve --port=8081 然后添加几个区块和交易 ， 因为我们要验证解决冲突 ， 所以应该比运行在8080端口上的区块多 。 1curl -s -X POST localhost:8081/block | python -m json.tool 重复几次操作 ， 最后看下8081伤的blockchain 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&#123; \"blocks\": [ &#123; \"dateCreated\": \"2018-08-11 17:35:15\", \"hash\": \"1152cb1aac50abd803a4589f28c7e054db207e23\", \"id\": 1, \"index\": 0, \"message\": \"\\u6b64\\u533a\\u5757\\u5df2\\u6dfb\\u52a0\\u81f3\\u533a\\u5757\\u94fe\", \"nonce\": 215, \"previousHash\": \"0\", \"transactions\": [ &#123; \"amount\": 200, \"from\": \"mayun\", \"to\": \"Felix\" &#125;, &#123; \"amount\": 200, \"from\": \"mayun\", \"to\": \"Felix\" &#125;, &#123; \"amount\": 200, \"from\": \"mayun\", \"to\": \"Felix\" &#125; ] &#125;, &#123; \"dateCreated\": \"2018-08-11 17:37:18\", \"hash\": \"1127f8c712ae3205ccbab9788392bcd190b8b6b1\", \"id\": 2, \"index\": 1, \"message\": \"\\u6b64\\u533a\\u5757\\u5df2\\u6dfb\\u52a0\\u81f3\\u533a\\u5757\\u94fe\", \"nonce\": 380, \"previousHash\": \"1152cb1aac50abd803a4589f28c7e054db207e23\", \"transactions\": [ &#123; \"amount\": 200, \"from\": \"mayun\", \"to\": \"Felix\" &#125;, &#123; \"amount\": 200, \"from\": \"mayun\", \"to\": \"Felix\" &#125; ] &#125;, &#123; \"dateCreated\": \"2018-08-11 17:37:39\", \"hash\": \"11b5d293c3068081f1771f14f96a3e450f282171\", \"id\": 3, \"index\": 2, \"message\": \"\\u6b64\\u533a\\u5757\\u5df2\\u6dfb\\u52a0\\u81f3\\u533a\\u5757\\u94fe\", \"nonce\": 64, \"previousHash\": \"1127f8c712ae3205ccbab9788392bcd190b8b6b1\", \"transactions\": [ &#123; \"amount\": 200, \"from\": \"mayun\", \"to\": \"Felix\" &#125;, &#123; \"amount\": 200, \"from\": \"mayun\", \"to\": \"Felix\" &#125; ] &#125;, &#123; \"dateCreated\": \"2018-08-11 17:37:45\", \"hash\": \"11d97dfca7cc7a67c22b9df06017768fca0a193f\", \"id\": 4, \"index\": 3, \"message\": \"\\u6b64\\u533a\\u5757\\u5df2\\u6dfb\\u52a0\\u81f3\\u533a\\u5757\\u94fe\", \"nonce\": 125, \"previousHash\": \"11b5d293c3068081f1771f14f96a3e450f282171\", \"transactions\": [ &#123; \"amount\": 200, \"from\": \"mayun\", \"to\": \"Felix\" &#125;, &#123; \"amount\": 200, \"from\": \"mayun\", \"to\": \"Felix\" &#125; ] &#125;, &#123; \"dateCreated\": \"2018-08-11 17:38:03\", \"hash\": \"115a991bd5d2ebe6e232b421965ab852b97a4202\", \"id\": 5, \"index\": 4, \"message\": \"\\u6b64\\u533a\\u5757\\u5df2\\u6dfb\\u52a0\\u81f3\\u533a\\u5757\\u94fe\", \"nonce\": 220, \"previousHash\": \"11d97dfca7cc7a67c22b9df06017768fca0a193f\", \"transactions\": [ &#123; \"amount\": 200, \"from\": \"mayun\", \"to\": \"Felix\" &#125;, &#123; \"amount\": 200, \"from\": \"mayun\", \"to\": \"Felix\" &#125; ] &#125; ], \"id\": 1&#125; 然后我们要让8080知道有这么一个节点 1curl -s -X POST localhost:8080/node --data \"address=localhost:8081\" | python -m json.tool 我们会看到节点已经注册成功了 1234&#123; \"address\": \"localhost:8081\", \"id\": 1&#125; 这时我们让8080去主动解决冲突 1curl -s -X POST localhost:8080/resolve | python -m json.tool 再查看8080上的区块链 ， 发现已经被替换为较长的8081上的blocks了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&#123; \"blocks\": [ &#123; \"dateCreated\": \"2018-08-11 17:35:15\", \"hash\": \"1152cb1aac50abd803a4589f28c7e054db207e23\", \"id\": 1, \"index\": 0, \"message\": \"\\u6b64\\u533a\\u5757\\u5df2\\u6dfb\\u52a0\\u81f3\\u533a\\u5757\\u94fe\", \"nonce\": 215, \"previousHash\": \"0\", \"transactions\": [ &#123; \"amount\": 200, \"from\": \"mayun\", \"to\": \"Felix\" &#125;, &#123; \"amount\": 200, \"from\": \"mayun\", \"to\": \"Felix\" &#125;, &#123; \"amount\": 200, \"from\": \"mayun\", \"to\": \"Felix\" &#125; ] &#125;, &#123; \"dateCreated\": \"2018-08-11 17:37:18\", \"hash\": \"1127f8c712ae3205ccbab9788392bcd190b8b6b1\", \"id\": 2, \"index\": 1, \"message\": \"\\u6b64\\u533a\\u5757\\u5df2\\u6dfb\\u52a0\\u81f3\\u533a\\u5757\\u94fe\", \"nonce\": 380, \"previousHash\": \"1152cb1aac50abd803a4589f28c7e054db207e23\", \"transactions\": [ &#123; \"amount\": 200, \"from\": \"mayun\", \"to\": \"Felix\" &#125;, &#123; \"amount\": 200, \"from\": \"mayun\", \"to\": \"Felix\" &#125; ] &#125;, &#123; \"dateCreated\": \"2018-08-11 17:37:39\", \"hash\": \"11b5d293c3068081f1771f14f96a3e450f282171\", \"id\": 3, \"index\": 2, \"message\": \"\\u6b64\\u533a\\u5757\\u5df2\\u6dfb\\u52a0\\u81f3\\u533a\\u5757\\u94fe\", \"nonce\": 64, \"previousHash\": \"1127f8c712ae3205ccbab9788392bcd190b8b6b1\", \"transactions\": [ &#123; \"amount\": 200, \"from\": \"mayun\", \"to\": \"Felix\" &#125;, &#123; \"amount\": 200, \"from\": \"mayun\", \"to\": \"Felix\" &#125; ] &#125;, &#123; \"dateCreated\": \"2018-08-11 17:37:45\", \"hash\": \"11d97dfca7cc7a67c22b9df06017768fca0a193f\", \"id\": 4, \"index\": 3, \"message\": \"\\u6b64\\u533a\\u5757\\u5df2\\u6dfb\\u52a0\\u81f3\\u533a\\u5757\\u94fe\", \"nonce\": 125, \"previousHash\": \"11b5d293c3068081f1771f14f96a3e450f282171\", \"transactions\": [ &#123; \"amount\": 200, \"from\": \"mayun\", \"to\": \"Felix\" &#125;, &#123; \"amount\": 200, \"from\": \"mayun\", \"to\": \"Felix\" &#125; ] &#125;, &#123; \"dateCreated\": \"2018-08-11 17:38:03\", \"hash\": \"115a991bd5d2ebe6e232b421965ab852b97a4202\", \"id\": 5, \"index\": 4, \"message\": \"\\u6b64\\u533a\\u5757\\u5df2\\u6dfb\\u52a0\\u81f3\\u533a\\u5757\\u94fe\", \"nonce\": 220, \"previousHash\": \"11d97dfca7cc7a67c22b9df06017768fca0a193f\", \"transactions\": [ &#123; \"amount\": 200, \"from\": \"mayun\", \"to\": \"Felix\" &#125;, &#123; \"amount\": 200, \"from\": \"mayun\", \"to\": \"Felix\" &#125; ] &#125; ], \"id\": 1&#125; summary可以看到大概区块链的设计还是比较有意思的 ， 细节部分请不要在意（比如sha1和prefix“11” 😄） 基本的介绍就到这里啦 ， 限于本人的水平可能会有错误请不要全信 。 打扰了 .","categories":[],"tags":[{"name":"swift","slug":"swift","permalink":"https://felixplusplus.github.io/tags/swift/"},{"name":"blockChain","slug":"blockChain","permalink":"https://felixplusplus.github.io/tags/blockChain/"}]},{"title":"磨刀不误砍柴之cocoapods","slug":"cocoapod","date":"2018-07-25T02:02:38.000Z","updated":"2018-08-18T10:50:01.167Z","comments":true,"path":"2018/07/25/cocoapod/","link":"","permalink":"https://felixplusplus.github.io/2018/07/25/cocoapod/","excerpt":"","text":"简介 CocoaPods是OS X和iOS下的一个第三类库管理工具，通过CocoaPods工具我们可以为项目添加被称为“Pods”的依赖库（这些类库必须是CocoaPods本身所支持的），并且可以轻松管理其版本。 CocoaPods意义体现在两个方面： 第一，在引入第三方库时它可以自动为我们完成各种各样的配置，包括配置编译阶段、连接器选项、甚至是ARC环境下的-fno-objc-arc配置等。 第二，使用CocoaPods可以很方便地查找新的第三方库，这些类库是比较“标准的”，而不是网上随便找到的，这样可以让我们找到真正好用的类库。 安装使用安装1sudo gem install cocoapods 查看版本1pod --version 在开发中安装使用cocoapods要注意版本 ， 因为一般开发过程中要大家一起使用同一个工程 ，一般为了指定版本我们会在工程下存放一个Gemfile来指定使用cocoapods的版本 ， 这里不过多介绍 。 指定版本除了指定Gemfile以外 ， 我们还可以安装指定版本的pods 1sudo gem install cocoapods -v 1.3.1 再查看一下pod版本我们就会发现已经安装了1.3.1 1pod --version 卸载掉不需要的版本当我们本地同时存在多个版本的pod的时候可以把多余的卸载掉 1sudo gem uninstall cocoapods 会提示我们选择卸载的版本 12345Select gem to uninstall: 1. cocoapods-1.2.1 2. cocoapods-1.3.1 3. All versions&gt; 我们选择想要卸载的版本的序号就好了 。 查找cocoapods支持我们去查找想要使用的仓库 , 比如我们想查找ReactoveObjC这个库 1pod spec cat ReactiveObjC 1234567891011121314151617181920212223242526272829303132333435363738394041424344&#123; \"name\": \"ReactiveObjC\", \"version\": \"3.1.0\", \"summary\": \"The 2.x ReactiveCocoa Objective-C API: Streams of values over time\", \"description\": \"ReactiveObjC (formally ReactiveCocoa or RAC) is an Objective-C\\nframework inspired by [Functional Reactive Programming](\\nhttp://en.wikipedia.org/wiki/Functional_reactive_programming).\\nIt provides APIs for composing and **transforming streams of values**.\", \"homepage\": \"https://reactivecocoa.io\", \"screenshots\": \"https://reactivecocoa.io/img/logo.png\", \"license\": &#123; \"type\": \"MIT\", \"file\": \"LICENSE.md\" &#125;, \"documentation_url\": \"https://github.com/ReactiveCocoa/ReactiveObjC/tree/master/Documentation#readme\", \"authors\": \"ReactiveCocoa\", \"social_media_url\": \"https://twitter.com/ReactiveCocoa\", \"platforms\": &#123; \"ios\": \"8.0\", \"osx\": \"10.9\", \"watchos\": \"2.0\", \"tvos\": \"9.0\" &#125;, \"source\": &#123; \"git\": \"https://github.com/ReactiveCocoa/ReactiveObjC.git\", \"tag\": \"3.1.0\" &#125;, \"source_files\": [ \"ReactiveObjC/*.&#123;h,m,d&#125;\", \"ReactiveObjC/extobjc/*.&#123;h,m&#125;\" ], \"private_header_files\": [ \"**/*Private.h\", \"**/*EXTRuntimeExtensions.h\", \"**/RACEmpty*.h\" ], \"ios\": &#123; \"exclude_files\": \"ReactiveObjC/**/*&#123;AppKit,NSControl,NSText,NSTable&#125;*\" &#125;, \"osx\": &#123; \"exclude_files\": \"ReactiveObjC/**/*&#123;UIActionSheet,UIAlertView,UIBarButtonItem,UIButton,UICollectionReusableView,UIControl,UIDatePicker,UIGestureRecognizer,UIImagePicker,UIRefreshControl,UISegmentedControl,UISlider,UIStepper,UISwitch,UITableViewCell,UITableViewHeaderFooterView,UIText,MK&#125;*\" &#125;, \"tvos\": &#123; \"exclude_files\": \"ReactiveObjC/**/*&#123;AppKit,NSControl,NSText,NSTable,UIActionSheet,UIAlertView,UIDatePicker,UIImagePicker,UIRefreshControl,UISlider,UIStepper,UISwitch,MK&#125;*\" &#125;, \"watchos\": &#123; \"exclude_files\": \"ReactiveObjC/**/*&#123;UIActionSheet,UIAlertView,UIBarButtonItem,UIButton,UICollectionReusableView,UIControl,UIDatePicker,UIGestureRecognizer,UIImagePicker,UIRefreshControl,UISegmentedControl,UISlider,UIStepper,UISwitch,UITableViewCell,UITableViewHeaderFooterView,UIText,MK,AppKit,NSControl,NSText,NSTable,NSURLConnection&#125;*\" 我们可以看到一大堆有的没的信息 ， 包括该pod仓库的实际仓库的地址和一些base信息 开始使用首先 ， 新建一个singlgViewApp ，然后在命令行进入该project目录 1pod init 12345678910# Uncomment the next line to define a global platform for your project# platform :ios, '9.0'target 'Test' do # Uncomment the next line if you're using Swift or would like to use dynamic frameworks # use_frameworks! # Pods for ocTestend 我们可以看到cocoapods为我们生成了一个Podfileplatform表示这个工程安装的设备 ， 后面是系统最低版本现在我们可以在里面添加一下刚才搜索的仓库 123456789# Uncomment the next line to define a global platform for your projectplatform :ios, '9.0'target 'ocTest' do # Uncomment the next line if you're using Swift or would like to use dynamic frameworks # use_frameworks! pod 'ReactiveObjC' # Pods for ocTestend 这里我们添加了一个仓库 ，接下来再命令行执行pod update来安装所需要的仓库 ， 安装完毕后我们可以看到当前路径下有两个工程文件 Test.xcodeproj Test.xcworkspace 我们在使用了cocoapods管理第三方库的时候 ， 每次install或者update的时候就会生成*.xcworkspace这个文件 ， 我们就用这个工程开发调试就好了 。 现在打开工程 ， 定位到viewController.m中就可以引用并使用ReactiveObjC啦 。 使用私有源公司内部有自己搭建的gitlab服务时 ， 有的公司搭建的gitlab服务为了安全并没有提供外网接口 ， 我们只能在内网访问 ， 这时候就要在podfile中添加私有源的地址 12source 'http://xx.xxxx.com/ios/cocoapods-spec.git'source 'https://github.com/CocoaPods/Specs.git' # 官方库 上面那个就是我们要添加的私有源地址 ， 下面的是官方源地址 ，如果都不写的话那么默认就会使用官方源 。 发布自己的pod发布pod分为发布到官方源和发布到私有源 , 这里暂不表发布到官方源 。重点来讲一下发布到私有源 。 创建仓库1pod lib create TDFCommonUtil pod会给出一些选项让我们选择 123456789101112131415161718192021To get you started we need to ask a few questions, this should only take a minute.If this is your first time we recommend running through with the guide: - https://guides.cocoapods.org/making/using-pod-lib-create.html ( hold cmd and click links to open in a browser. )What platform do you want to use?? [ iOS / macOS ] &gt;iosWhat language do you want to use?? [ Swift / ObjC ] &gt;swiftWould you like to include a demo application with your library? [ Yes / No ] &gt;yesWhich testing frameworks will you use? [ Quick / None ] &gt; NoneWould you like to do view based testing? [ Yes / No ] &gt; NO 都填写完后会自动打开一个工程 。 添加基本信息cd进入刚才创建的目录 执行命令 ls 12Example README.md TDFCommonUtil.podspecLICENSE TDFCommonUtil _Pods.xcodeproj 解释一下这里都是啥 Example 这里面就是示例工程 README.md 这里面是我们对改pod功能和使用等的介绍 ， 使用markdown语法 TDFCommonUtil.podspec 这里是改模块的全部基本信息 LICENSE 这里放的是改开源项目遵守的协议 TDFCommonUtil 这里放着全部的类文件和资源文件 _Pods.xcodeproj 这是示例工程的快捷方式 我们首先要为我们的pod创建一个实际的git仓库 。 打开gitlab服务创建一个空的git仓库 然后先把pod目录提交到我们的仓库 blalblabla 打开TDFCommonUtil.podspec文件 12345678910111213141516171819202122232425262728Pod::Spec.new do |s| s.name = 'TDFCommonUtil' s.version = '0.1.0' s.summary = 'A short description of TDFCommonUtil.' s.description = &lt;&lt;-DESCTODO: Add long description of the pod here. DESC s.homepage = 'https://github.com/xxxxx@yeah.net/TDFCommonUtil' s.license = &#123; :type =&gt; 'MIT', :file =&gt; 'LICENSE' &#125; s.author = &#123; 'xxxxx' =&gt; 'xxxxx@2dfire.com' &#125; s.source = &#123; :git =&gt; 'https://github.com/xxxxx@yeah.net/TDFCommonUtil.git', :tag =&gt; s.version.to_s &#125; s.ios.deployment_target = '8.0' s.source_files = 'TDFCommonUtil/Classes/**/*' # s.resource_bundles = &#123; # 'TDFCommonUtil' =&gt; ['TDFCommonUtil/Assets/*.png'] # &#125; # s.public_header_files = 'Pod/Classes/**/*.h' # s.frameworks = 'UIKit', 'MapKit' # s.dependency 'AFNetworking', '~&gt; 2.3'end 这里的配置项就是生成pod需要配置的大部分选项了 ，简单介绍一下 name pod名称 version 版本号 ，特别注意下在更新时需要对git仓库打tag summary 简介 description 描述 homepage 主页 license 使用协议 author 作者 deployment_target 需要系统版本 source_files 源文件路径 resource_bundles 资源文件路径 注意这里会把资源文件打包成bundle ， 调用的时候要注意下 public_header_files 公开的头文件 （有些头文件我们不想要外部看见可以在这里去掉） frameworks 需要依赖的framework库 dependency 需要依赖的其他pod 现在把这些填好吧 。 添加依赖有的时候我们开发的pod仓库需要依赖其他仓库 ， 比如我们需要依赖ReactiveObjC这里就可以在TDFCommonUtil.podspec下面添加这一行 1s.dependency 'ReactiveObjC' ps ，这里可以指向特定的版本也可以用 ‘~&gt; 2.3’ 的形式表示依赖此仓库至少大于2.3版本但是不会超过3.0 。 lint检测一切就绪后你可以在里面创建你的文件 ， 添加代码了 ，别忘了再有文件的增加或删除后在运行一遍 ‘pod install’ 哦 。 先随便创建几个文件 ， 保证编译不报错就可以了 ，然后我们使用cocoapods检测我们的库 1pod lib lint --sources='git@git.xxx.com:ios/cocoapods-spec.git' --use-libraries --allow-warnings --verbose --no-clean 这里的sources填写你所使用的私有gitlab服务 ，然后我们就可以静静的看着命令行了 。 最后会出现 1Test passed validation. 证明你的库是可运行的 ， 如果没有出现passed就注意下输出中的error信息 ，看下是什么导致的 。 向私有源推送lint通过后我们就可以把自己的仓库信息推送到私有源了 ， 注意不是「仓库」是「仓库信息」，也就是x.podspec 。cocoapod可以自动帮我们完成这件事情 1pod repo push xxx-cocoapods-spec TDFOpenShopSDK.podspec --sources=git@git.xxx.com:ios/cocoapods-spec.git --allow-warnings --use-libraries --verbose 把命令中的xxx替换为你的私有源和仓库就可以了 。 总结以上基本是我们工作中常用的cocoapods的方法了 ， 还有一些动态静态库依赖的问题暂时不做总结 ， 后续再谈谈自己遇到过的坑 ， 比上面这些加起来还要精彩哦 ，欢迎email讨论","categories":[],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://felixplusplus.github.io/tags/Objective-C/"},{"name":"cocoapods","slug":"cocoapods","permalink":"https://felixplusplus.github.io/tags/cocoapods/"}]},{"title":"NSCache","slug":"NSCache","date":"2018-07-25T02:01:56.000Z","updated":"2018-08-18T10:51:55.834Z","comments":true,"path":"2018/07/25/NSCache/","link":"","permalink":"https://felixplusplus.github.io/2018/07/25/NSCache/","excerpt":"","text":"基本 NSCache 基本上就是一个会自动移除对象来释放内存的 NSMutableDictionary。无需响应内存警告或者使用计时器来清除缓存。唯一的不同之处是键对象不会像 NSMutableDictionary 中那样被复制，这实际上是它的一个优点（键不需要实现 NSCopying 协议）。 优点 NSCache是一个类似NSDictionary一个可变的集合。 提供了可设置缓存的数目与内存大小限制的方式。 保证了处理的数据的线程安全性。 缓存使用的key不需要是实现NSCopying的类。 当内存警告时内部自动清理部分缓存数据。 属性与方法1@property (assign) id&lt;NSCacheDelegate&gt;delegate; cache对象的代理 ， 用来即将清理cache的时候得到通知 1- (void)cache:(NSCache *)cache willEvictObject:(id)obj; 代理方法 ， 这里面不要对cache进行改动 ， 如果对象obj需要被持久化存储的话可以在这里进行操作 这里面有几种情况会导致该方法执行： 手动移除（removeObjectForKey） 缓存超过设定的上线 App不活跃 系统内存爆炸 1@property BOOL evictsObjectsWithDiscardedContent; 该属性默认为True ， 表示在内存销毁时丢弃该对象 。 1@property NSUInteger totalCostLimit; 总成本数 ， 用来设置最大缓存数量 使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//// TDFSetPhoneNumController.m// TDFLoginModule//// Created by doubanjiang on 2017/6/5.// Copyright © 2017年 doubanjiang. All rights reserved.//#import \"viewController.h\"@interface viewController () &lt;NSCacheDelegate&gt;@property (nonatomic ,strong) NSCache *cache;@end@implementation viewController- (void)viewDidLoad &#123; [super viewDidLoad]; [self beginCache];&#125;- (void)beginCache &#123; for (int i = 0; i&lt;10; i++) &#123; NSString *obj = [NSString stringWithFormat:@\"object--%d\",i]; [self.cache setObject:obj forKey:@(i) cost:1]; NSLog(@\"%@ cached\",obj); &#125;&#125;#pragma mark - NSCacheDelegate- (void)cache:(NSCache *)cache willEvictObject:(id)obj &#123; //evict : 驱逐 NSLog(@\"%@\", [NSString stringWithFormat:@\"%@ will be evict\",obj]);&#125;#pragma mark - Getter- (NSCache *)cache &#123; if (!_cache) &#123; _cache = [NSCache new]; _cache.totalCostLimit = 5; _cache.delegate = self; &#125; return _cache;&#125;@end 我们会看到以下输出 1234567891011121314152018-07-31 09:30:56.485719+0800 Test_Example[52839:214698] object--0 cached2018-07-31 09:30:56.485904+0800 Test_Example[52839:214698] object--1 cached2018-07-31 09:30:56.486024+0800 Test_Example[52839:214698] object--2 cached2018-07-31 09:30:56.486113+0800 Test_Example[52839:214698] object--3 cached2018-07-31 09:30:56.486254+0800 Test_Example[52839:214698] object--4 cached2018-07-31 09:30:56.486382+0800 Test_Example[52839:214698] object--0 will be evict2018-07-31 09:30:56.486480+0800 Test_Example[52839:214698] object--5 cached2018-07-31 09:30:56.486598+0800 Test_Example[52839:214698] object--1 will be evict2018-07-31 09:30:56.486681+0800 Test_Example[52839:214698] object--6 cached2018-07-31 09:30:56.486795+0800 Test_Example[52839:214698] object--2 will be evict2018-07-31 09:30:56.486888+0800 Test_Example[52839:214698] object--7 cached2018-07-31 09:30:56.486995+0800 Test_Example[52839:214698] object--3 will be evict2018-07-31 09:30:56.487190+0800 Test_Example[52839:214698] object--8 cached2018-07-31 09:30:56.487446+0800 Test_Example[52839:214698] object--4 will be evict2018-07-31 09:30:56.487604+0800 Test_Example[52839:214698] object--9 cached 总结经过实验我们发现NSCache使用上性价比还是比较高的 ， 比一些瞎折腾出来的缓存好用很多 。","categories":[],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://felixplusplus.github.io/tags/Objective-C/"},{"name":"NSCache","slug":"NSCache","permalink":"https://felixplusplus.github.io/tags/NSCache/"}]},{"title":"RxSwift","slug":"rxswift","date":"2018-07-24T06:32:19.000Z","updated":"2018-08-18T10:52:05.132Z","comments":true,"path":"2018/07/24/rxswift/","link":"","permalink":"https://felixplusplus.github.io/2018/07/24/rxswift/","excerpt":"","text":"基本 RxSwift 是在 Apple 推出 Swift 后， ReactiveX 推出 Reactive Extensions 系列一个实现库。但是学习 RxSwift 不是学习如何使用第三方库，而是学习一个思想。 编程范式 编程范型、编程范式或程序设计法（英语：Programming paradigm），（范即模范、典范之意，范式即模式、方法），是一类典型的编程风格，是指从事软件工程的一类典型的风格（可以对照方法学）。如：函数式编程、程序编程、面向对象编程、指令式编程等等为不同的编程范型。编程范型提供了（同时决定了）程序员对程序执行的看法。例如，在面向对象编程中，程序员认为程序是一系列相互作用的对象，而在函数式编程中一个程序会被看作是一个无状态的函数计算的序列。 函数式 简单说，”函数式编程”是一种”编程范式”（programming paradigm），也就是如何编写程序的方法论。它属于”结构化编程”的一种，主要思想是把运算过程尽量写成一系列嵌套的函数调用。 响应式 在计算机中，响应式编程或反应式编程（英语：Reactive programming）是一种面向数据流和变化传播的编程范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。 RxSwift核心 Observable 可观测序列 Observer 观察者 Operator 创建变化组合事件 Disposable 管理订阅生命周期 Schedulers 线程队列 Observable简单来说 ， Observable即使可被观察的序列 ， 就像数组一样：[1,2,3,4,5] 而我对Observable的理解则是加上了时间维度的数组 ， 这个数组会随着时间的变化而变化 。 在这里你可以想象一下温度的变化 : [35,35.1,35.4,38,爆炸] 海平面的升高 : [海拔100m，海拔110m，海拔112m]大概这样理解比较直观 。 12345678910111213141516171819let numbers: Observable&lt;Int&gt; = Observable.create &#123; observer -&gt; Disposable in observer.onNext(0) observer.onNext(1) observer.onNext(2) observer.onNext(3) observer.onNext(4) observer.onNext(5) observer.onNext(6) observer.onNext(7) observer.onNext(8) observer.onNext(9) observer.onCompleted() return Disposables.create() &#125; _ = numbers.takeUntil(self.rx.deallocated).subscribe(onNext: &#123; a in print(a) &#125;) ObserverObserver 是一个订阅者 ， 它可以观察「可被观察序列」的变化 AnyObserverBinderOperatorDisposableSchedulersMVVM示例","categories":[],"tags":[{"name":"swift","slug":"swift","permalink":"https://felixplusplus.github.io/tags/swift/"}]},{"title":"AOP","slug":"aop","date":"2018-07-24T06:32:12.000Z","updated":"2018-08-18T10:49:50.185Z","comments":true,"path":"2018/07/24/aop/","link":"","permalink":"https://felixplusplus.github.io/2018/07/24/aop/","excerpt":"","text":"Aspect Oriented Programming基本概念AOP 直译为 （面向切面编程） 以下引用自wikipedia 面向侧面的程序设计（aspect-oriented programming，AOP，又译作面向方面的程序设计、观点导向编程、剖面导向程序设计）是计算机科学中的一个术语，指一种程序设计范型。该范型以一种称为侧面（aspect，又译作方面）的语言构造为基础，侧面是一种新的模块化机制，用来描述分散在对象、类或函数中的横切关注点（crosscutting concern）。侧面的概念源于对面向对象的程序设计的改进，但并不只限于此，它还可以用来改进传统的函数。与侧面相关的编程概念还包括元对象协议、主题（subject）、混入（mixin）和委托。 面向对象(OOP)我们都知道面向对象的三大特点是： 继承 封装 多态 其中 ， 分装的要求是将功能分散到不同的类中 ， 执行职责划分 ， 这样就降低了代码的复杂度 ， 同时也让类和对象更易读易懂 。但是有的时候几个不同的类可能会需要执行相同的方法 ， 比如在页面跳转的时候进行埋点记录 、 将当前页面的标识发送给服务端记录 。这里你可能会想 ，写个类把这块代码封装一下 ， 再在需要的地方调用不就可以了 。想一下 ， 当我们这个方法调用的api需要改写的时候会怎么样呢 ， 所有之前的调用处都需要改写 。AOP就是为了这种情况而生的 ， 有了它我们可以把需要执行的代码切入到特定的类的指定位置（方法）中 。 一般我们把这段需要执行的代码叫做切面 , 这组代码中的一份叫做切片 , 切入的位置叫做切入点 。 这样看来 ， 有了AOP ， 我们的OOP就更加立体了 ， 我们可以在不修改源代码的前提下实现统一的某种需要执行的操作 。 iOS中的应用对于我们iOS程序员来说 ， 我们在App中应用AOP最好的方式是通过runtime的methodswizzing ， runtime是一个比较难用的库 ， 因为比较底层 ，这里介绍一下Aspects这个库 ， 可以让我们方便的进行方法交换 安装这里我们使用cocoapod管理三方库 1pod \"Aspects\" 简单使用首先创建一个工程 ， 安装Aspects ， 然后在appdelegate中的代理方法中添加如下代码： 123[UIViewController aspect_hookSelector:@selector(viewWillAppear:) withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo, BOOL animated) &#123; NSLog(@\"View Controller %@ will appear animated: %tu\", aspectInfo.instance, animated);&#125; error:NULL]; 这样 ，我们就hook了UIViewController的viewWillAppear方法 ， 可以在这里插入切片了 源代码解读pass","categories":[],"tags":[{"name":"AOP","slug":"AOP","permalink":"https://felixplusplus.github.io/tags/AOP/"},{"name":"Objective-C","slug":"Objective-C","permalink":"https://felixplusplus.github.io/tags/Objective-C/"}]},{"title":"iOS UnitTest XCTest 使用小结","slug":"unitTest","date":"2018-06-10T11:33:49.000Z","updated":"2018-08-18T10:52:29.983Z","comments":true,"path":"2018/06/10/unitTest/","link":"","permalink":"https://felixplusplus.github.io/2018/06/10/unitTest/","excerpt":"","text":"UT在开发或是维护一些功能的时候，往往我们自以为是的没问题，全弄好了，根本不会出问题（微笑for me）是根本靠不住的，这时候就需要我们掏出单元测试撸一遍，如果没问题再去让测试大大帮我们把关，今天就谈一下iOS测试类XCTest。 使用场景 工具类，和我们的一些外部扩展的方法稳定性 性能测试 网络接口测试 方法介绍123- (void)setUp &#123; [super setUp];&#125; 当测试执行之前要做的是，相当于可以把所有的初始化工作放在这里 123- (void)tearDown &#123; [super tearDown];&#125; 当测试执行完后要做的事 简单使用 首先，在你要测试的project中新建一个Test target 新建一个类，继承 XCTestCase 现在，我们就可以写测试代码啦 123456789101112131415@implementation TDFTestCase- (void)setUp &#123; [super setUp]; // 设置bundleVersion [[[NSBundle mainBundle]infoDictionary]setValue:@\"5660\" forKey:@\"CFBundleShortVersionString\"];&#125;- (void)tearDown &#123; // Put teardown code here. This method is called after the invocation of each test method in the class. [super tearDown];&#125;- (void)testHTTPDNSPOD &#123; &#125;@end 在测试类中，每一个以test开头的方法都是一个测试方法，下面来让我们几个试一下吧 假设有这样一个类 12345@implementation FXCalculator+ (NSInteger)zero &#123; return 0;&#125;@end 这个类有一个类方法，作用也很简单，就是返回一个0，我们要写一个测试方法，来证明返回值确实是0下面，我们在TDFTestCase.m文件的implementation中写这样一个测试方法 1234- (void)testThatCalculateZeroCorrect&#123; XCTAssert(0==[FXCalculator zero]); &#125; 很简单，XCTAssert接收一个条件，当条件满足时，测试通过你会发现函数左边出现一个菱形按钮，我们点击这个按钮，biu～Test Success 但是这只是测试一个方法，当我们想要测试一组方法的时候呢 添加一个方法到FXCalculator中 123+ (NSInteger)one &#123; return 1;&#125; 再添加一个测试方法到TDFTestCase.m 123+ (NSInteger)one &#123; return 1;&#125; 点击 1@implementation TDFTestCase 左边的菱形按钮，这些方法就会依次执行下去 性能测试现在我们先添加一个函数，这是一个阶乘函数，递归调用自身 123456+ (NSInteger)factorial:(NSInteger )i &#123; if (!i) &#123; return 1; &#125; return i*[self factorial:i-1];&#125; 来一个测试函数 123456- (void)testThatCalculateFactorial&#123; NSInteger i = [FXCalculator factorial:4]; XCTAssert(i == 24);&#125; 4的阶乘是24，现在我们测试成功，那我们想测试以下阶乘方法的性能怎么办呢 只要使用XCTest提供给我们的一个block就可以啦 123456- (void)testThatCalculateFactorial&#123; [self measureBlock:^&#123; [FXCalculator factorial:100]; &#125;];&#125; 点击开始测试，完成后你会看到measureBlock这一行的左面出现一个灰色的按钮，点按就可以看到该方法的性能测试啦选中Baseline，可以设置性能的基线，也就是合格线 异步测试有时候我们相对网络请求进行测试，如何测试异步方法呢比如我前一段时间改造网络框架，担心自己哪里写出了问题，跑去找boss商量，经过boss的提醒我决定先搞几个接口测试出来这样不论我怎么改造，因为不涉及外部调用，所以只要测试全部通过就说明没啥问题那么接口测试咋写呢 12345678910111213141516171819202122- (void)testThatLoginWithParamsNull &#123; //生成expection XCTestExpectation *expection = [self expectationWithDescription:@\"login request\"]; //发送请求 TDFRequest *req = [self loginRequestModelInBossApi]; [[self client] sendRequestWithRequestModel:req progress:nil callback:^(TDFResponse * _Nullable res) &#123; //表示条件满足，测试可以执行 [expection fulfill]; XCTAssertNotNil(res.responseObject); XCTAssertEqual(res.responseObject[@\"code\"], [NSNumber numberWithInteger:0]); &#125;]; // 等待异步任务超时 [self waitForExpectationsWithTimeout:self.networkTimeout handler:^(NSError * _Nullable error) &#123; if (error) &#123; XCTFail(\"Time out\"); &#125; &#125;];&#125; 测试断言命令123456789101112131415161718192021222324252627282930313233343536XCTFail(format…) 生成一个失败的测试；XCTAssertNil(a1, format...)为空判断，a1为空时通过，反之不通过；XCTAssertNotNil(a1, format…)不为空判断，a1不为空时通过，反之不通过；XCTAssert(expression, format...)当expression求值为TRUE时通过；XCTAssertTrue(expression, format...)当expression求值为TRUE时通过；XCTAssertFalse(expression, format...)当expression求值为False时通过；XCTAssertEqualObjects(a1, a2, format...)判断相等，[a1 isEqual:a2]值为TRUE时通过，其中一个不为空时，不通过；XCTAssertNotEqualObjects(a1, a2, format...)判断不等，[a1 isEqual:a2]值为False时通过，XCTAssertEqual(a1, a2, format...)判断相等（当a1和a2是 C语言标量、结构体或联合体时使用,实际测试发现NSString也可以）；XCTAssertNotEqual(a1, a2, format...)判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；XCTAssertEqualWithAccuracy(a1, a2, accuracy, format...)判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/-accuracy）以内相等时通过测试；XCTAssertNotEqualWithAccuracy(a1, a2, accuracy, format...) 判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试；XCTAssertThrows(expression, format...)异常测试，当expression发生异常时通过；反之不通过；（很变态）XCTAssertThrowsSpecific(expression, specificException, format...) 异常测试，当expression发生specificException异常时通过；反之发生其他异常或不发生异常均不通过；XCTAssertThrowsSpecificNamed(expression, specificException, exception_name, format...)异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过；XCTAssertNoThrow(expression, format…)异常测试，当expression没有发生异常时通过测试；XCTAssertNoThrowSpecific(expression, specificException, format...)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过；XCTAssertNoThrowSpecificNamed(expression, specificException, exception_name, format...)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过. 单元测试就先总结到这里，欢迎email讨论","categories":[],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://felixplusplus.github.io/tags/Objective-C/"},{"name":"XCTest","slug":"XCTest","permalink":"https://felixplusplus.github.io/tags/XCTest/"}]},{"title":"浅谈Objc的call method","slug":"methodcall","date":"2018-06-10T10:53:47.000Z","updated":"2018-08-18T10:51:24.453Z","comments":true,"path":"2018/06/10/methodcall/","link":"","permalink":"https://felixplusplus.github.io/2018/06/10/methodcall/","excerpt":"","text":"在OC中，我们一般都会写出这样的代码 1[SomeObj someMethod] 实际上这些调用都会转化为 1objc_msgSend(receiver, @selector(message)); 这样的形式 那么。这一切中间经历了怎样的过程呢，下面我们先介绍几个名词 SEL 我们写的OC代码，在编译阶段会对所有方法生成一个ID，用来区分不同的方法，同时只要是是相同的函数名称，这个ID是相同的 IMP 是一个函数指针，指向的是函数的实现首地址。在对象执行method的时候一般会先从方法列表里面查找相应的方法，如果我们直接使用IMP执行方法的话会省略这中间的很多步骤 Method Method = SEL + IMP + method_types 下面来直接看看方法调用流程吧 检查方法是否需要忽略 检查target是否为nil，如果为nil直接clean并return 根据target的class去寻找IMP并执行 寻找IMP过程 先从target class 的cache methodLists（方法缓存列表）查找 如果缓存列表没有，直接查找方法列表，找到了添加进方法缓存列表并执行 递归查找superClass 如果都没找到进入动态转发resolveInstanceMethod","categories":[],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://felixplusplus.github.io/tags/Objective-C/"}]},{"title":"浅谈Objective-C中的weak","slug":"weak","date":"2018-06-10T08:47:24.000Z","updated":"2018-08-18T10:52:36.624Z","comments":true,"path":"2018/06/10/weak/","link":"","permalink":"https://felixplusplus.github.io/2018/06/10/weak/","excerpt":"","text":"日常开发中我们使用weak大部分是为了修饰属性引用计数，防止循环引用、内存泄漏的作用，那么他的原理是什么呢， 原理简介 Runtime维护了一个weak表，用于存储指向某个对象的所有weak指针。weak表其实是一个hash（哈希）表，Key是所指对象的地址，Value是weak指针的地址（这个地址的值是所指对象的地址）数组。 初始化时：runtime会调用objc_initWeak函数，初始化一个新的weak指针指向对象的地址。 添加引用时：objc_initWeak函数会调用 objc_storeWeak() 函数， objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。 释放时，调用clearDeallocating函数。clearDeallocating函数首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。 当我们初始化一个weak变量时，runtime会调用 NSObject.mm 中的objc_initWeak函数。 添加引用时：objc_initWeak函数会调用 objc_storeWeak() 函数， objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。 weak表是一个弱引用表，实现为一个weak_table_t结构体，存储了某个对象相关的的所有的弱引用信息。 当销毁weak时又做了些什么呢 调用objc_release 因为对象的引用计数为0，所以执行dealloc 在dealloc中，调用了_objc_rootDealloc函数 在_objc_rootDealloc中，调用了object_dispose函数 调用objc_destructInstance 最后调用objc_clear_deallocating","categories":[],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://felixplusplus.github.io/tags/Objective-C/"}]},{"title":"iOS国际化小结","slug":"local","date":"2018-06-10T08:46:56.000Z","updated":"2018-08-18T10:51:10.583Z","comments":true,"path":"2018/06/10/local/","link":"","permalink":"https://felixplusplus.github.io/2018/06/10/local/","excerpt":"","text":"随着项目产品的发展，我们就需要适配多种国际化和地区，但是外国人还有一些不认识中文，我们又不能强迫他们去学习是吧所以我们需要对自己的产品进行国际化，让更多的人了解我们的APP，这就需要对我们的产品进行国际化了今天就介绍一下自己在国家化项目里面踩过的坑 主工程内配置配置project 打开你的工程 ， 在左侧栏选中project 在打开的面板中选中project下的蓝色图标 找到Localizations选项 ， 添加你需要国家化的语言 在主工程下command + N 新建Localizable.string文件 选中你创建的string文件 ， 打开右侧面板 点击Localization组下的Localize按钮 把你刚才配置在工程内的选项添加进去就好。 调用方式在以前调用的地方我们需要替换为本地化调用方式 比如以前我们是这么调用的： 1NSString *tips = @\"wait\"; 那么现在要换成 1NSString *tips = NSLocalizedString(@\"wait\", @\"some tips to tell user wait\"); 至于后面那段是为了方便翻译人员理解上下文语境使用的 。 然后在stirng文件内添加对应的字符串： 1\"wait\" = \"别着急\"; 这是对应中文的 ， 你可以在不同的文件添加对应不同语言的翻译 。 让我们看下这个宏的定义 ： 12345678#define NSLocalizedString(key, comment) \\ [NSBundle.mainBundle localizedStringForKey:(key) value:@\"\" table:nil]#define NSLocalizedStringFromTable(key, tbl, comment) \\ [NSBundle.mainBundle localizedStringForKey:(key) value:@\"\" table:(tbl)]#define NSLocalizedStringFromTableInBundle(key, tbl, bundle, comment) \\ [bundle localizedStringForKey:(key) value:@\"\" table:(tbl)]#define NSLocalizedStringWithDefaultValue(key, tbl, bundle, val, comment) \\ [bundle localizedStringForKey:(key) value:(val) table:(tbl)] 可以看到实际上就是从mainBundle中取出了指定的String文件 ， 然后根据我们在代码中定义的 ‘key’ 值取出value 这是一种情况 . 有的时候我们要指定我们的string文件名字而不使用上面的那个默认名字 。 1NSString *tips = NSLocalizedStringFromTableInBundle(@\"wait\", @\"TDFOSLocalizable\", [NSBundle bundleForClass:[self class]], @\"some tips to tell user wait\")； 这里面多出来两个参数 ， 第一个是我们要指定的string文件名字 ， 第二个就是要从哪个bundle中取 ， 这个bundle的问题我们下面就会讲到 。 脚本替换那么在我们工程很大的情况下我们要把全部的字符串都替换为前缀为NSLocalizedString的形式人工手动替换肯定是不行的 ， 又慢又不安全 ， 没准复制粘贴的时候还把原来的key改错了 。 这里贴一段python的实例代码 ，您可以稍加改动运行替换工程中的string前缀 。 123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/env python3# -*- coding: utf-8 -*-import osimport reimport sysimport datetimefolderPath = '/Users/felix/Documents/2dfire/TDFOpenShop/TDFOpenShop/Classes'stringToReplace = 'NSLocalizedString'stringReplaceTo = 'TDFOSLocalizedString'def scan_files(rootdir): files = [] for parent, dirnames, filenames in os.walk(rootdir): for filename in filenames: if len(filename.split('.',1))&gt;1: if filename.split('.',1)[1] == 'm': files.append(os.path.join(parent, filename)) return filesdef replaceStringIn(file): code = open(file,'r+') text = code.read() code.seek(0,0) code.write(text.replace(stringToReplace,stringReplaceTo)) code.close()def main(): files = scan_files(folderPath) for filePath in files: replaceStringIn(filePath)if __name__ == '__main__': main() 这里面我是把以前的NS开头的宏替换为自定义的宏 ， 大同小异 ， 可以参照这个修改下即可 。 编译运行测试当我们全部修改好以后肯定是要测试下显示对不对的 。这个时候按下command+B，编译运行 。 有两种方法可以快速将App语言切换掉 打开模拟器或真机 ， general -&gt; setting -&gt; lang ,不过这样比较繁琐 。 点击导航栏上的模拟器图标左边的schema选项 ， 选择editSchema -&gt; Run -&gt; Options -&gt;Application Language 直接改为你需要验证的语言运行就可以啦 。 模块内单独配置原因很多时候我们的工程体量大到一定程度的时候都会模块化掉 ， 几个人或者一个人负责一个模块 ， 而有的模块是要作为SDK提供外部interface使用的 。 当你把SDK提供出去的时候 ， 我们期望的效果是在其他人（其他工程）内部运行的、我们的SDK也能够国际化显示 。 但是在我们整个工程的string文件包含几千上万条的时候显然不需要全部移动到模块内 。 目标所以在这里面我们要做的就是把需要的使用到的字符串和翻译好的value从主工程迁移到模块内部 。 解决方案：使用cocoapods集成的模块化内部进行国际化这里我使用的是cocoapods1.2.1 。关于cocoapod的使用详见我的另一篇文章 。 我们先把主工程的国际化文件的文件夹复制到我们的模块路径下面 我们在模块内部有一个配置文件 ‘xxx.podspec’ 里面添加这样一段配置 1s.resources = 'xxx/*.&#123;xib,jpg,png,xcassets&#125;','xxx/*.lproj' 主要注意后面 , 这里就把我们刚复制来的国际化问价加入了模块的资源中 ，这时 ，如果我们不想用跟主工程一样的名字 ，Localizable.strings ，可以把这个名字也给改掉 ， 比如 abc.strings 调用这里为了有别于主工程的国际化 ， 我们把strings文件改名为 abc.strings 然后在模块内新建一个头文件 1234567#ifndef TDFOSLocalizeMacro_h#define TDFOSLocalizeMacro_h#define TDFOSLocalizedString(key, comment) \\NSLocalizedStringFromTableInBundle(key, @\"abc\", [NSBundle bundleForClass:[self class]], comment)#endif /* TDFOSLocalizeMacro_h */ 这里可以使用上面的脚本再次替换字符串前缀 ， 然后运行下看看是否替换成功了呢 。 这里主要重新pod install下 ， 否则cocoapods不会帮我们把资源引入包内 。 ps: 别忘了删掉主工程中移除来的字符串 ！！！ 总结基本用法暂时介绍到这里 ， 关于模块化和国际化的东西要多了解一下NSbundle这个类 。","categories":[],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://felixplusplus.github.io/tags/Objective-C/"},{"name":"iOS","slug":"iOS","permalink":"https://felixplusplus.github.io/tags/iOS/"}]},{"title":"浅谈GCD","slug":"gcd","date":"2018-06-10T08:46:48.000Z","updated":"2018-08-18T10:50:18.020Z","comments":true,"path":"2018/06/10/gcd/","link":"","permalink":"https://felixplusplus.github.io/2018/06/10/gcd/","excerpt":"","text":"基本概念进程 进程指在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令、数据和堆栈等组成的，是一个能独立运行的活动实体 线程 线程是进程的基本执行单元，一个进程（程序）的所有任务都在线程中执行。 队列 队列，又称为伫列（queue），是先进先出（FIFO, First-In-First-Out）的线性表。在具体应用中通常用链表或者数组来实现。队列只允许在后端（称为rear）进行插入操作，在前端（称为front）进行删除操作。队列的操作方式和堆栈类似，唯一的区别在于队列只允许新数据在后端进行添加。 同步/异步可以这么理解：（知乎） 假如你要做两件事，烧水、刷牙 同步：你烧水，等水烧开了你再去刷牙 异步：你烧水，不等水烧开就去刷牙了，水烧开了会发出声音告诉你（callback），然后你再处理水烧开之后的事情 只要你是个正常人，都会选择第二种 当然也有特殊情况，那个人喜欢用热水刷牙 并发 指两个或多个事件在同一时间间隔内发生。可以在某条线程和其他线程之间反复多次进行上下文切换，看上去就好像一个CPU能够并且执行多个线程一样。其实是伪异步。 线程队列中并行/串行 串行队列：串行队列的特点是队列内的线程是一个一个执行，直到结束。并行队列：并行队列的特点是队列中所有线程的执行结束时必须是一块的，队列中其他线程执行完毕后，会阻塞当前线程等待队列中其他线程执行，然后一块执行完毕。 基本用法123456789DispatchQueue.global().async &#123; print(\"do something in global \\(Thread.current)\") DispatchQueue.main.async &#123; print(\"do something in main \\(Thread.current)\") &#125;&#125; 这里使用了全局的队列执行一些任务 ， 然后切回主队列 , 这里要注意主队列是运行在主线程上的任务堆栈 。 自定义队列除了使用全局队列外我们还可以使用自定义的队列 1let q = DispatchQueue(label: \"com.felix.felix\") 初始化一个队列最简单的方式就是声明它的标签 。 async 现在 ，你可以打开Xcode ， 新建一个commandLineTool工程和我一起练习 。 打开main.swift 123456789101112131415let q = DispatchQueue(label: \"com.felix.felix\")q.sync &#123; (1...5).forEach(&#123; i in print(\"🍎 \\(Thread.current) + \\(i)\") &#125;)&#125;q.async &#123; (6...10).forEach(&#123; i in print(\"🍇 \\(Thread.current) + \\(i)\") &#125;)&#125;(11...15).forEach(&#123; i in print(\"🍌 \\(Thread.current) + \\(i)\")&#125;) 上面我们先是声明一个队列 , 使用sync添加一个同步的任务输出1到5 ， 使用async异步输出6到10 ， 同时在主线程打印11到15 。 按下command+R运行project ，我们可以看到一下输出 12345678910111213141516🍎 &lt;NSThread: 0x103103480&gt;&#123;number = 1, name = main&#125; + 1🍎 &lt;NSThread: 0x103103480&gt;&#123;number = 1, name = main&#125; + 2🍎 &lt;NSThread: 0x103103480&gt;&#123;number = 1, name = main&#125; + 3🍎 &lt;NSThread: 0x103103480&gt;&#123;number = 1, name = main&#125; + 4🍎 &lt;NSThread: 0x103103480&gt;&#123;number = 1, name = main&#125; + 5🍌 &lt;NSThread: 0x103103480&gt;&#123;number = 1, name = main&#125; + 11🍇 &lt;NSThread: 0x103007940&gt;&#123;number = 2, name = (null)&#125; + 6🍌 &lt;NSThread: 0x103103480&gt;&#123;number = 1, name = main&#125; + 12🍇 &lt;NSThread: 0x103007940&gt;&#123;number = 2, name = (null)&#125; + 7🍌 &lt;NSThread: 0x103103480&gt;&#123;number = 1, name = main&#125; + 13🍇 &lt;NSThread: 0x103007940&gt;&#123;number = 2, name = (null)&#125; + 8🍌 &lt;NSThread: 0x103103480&gt;&#123;number = 1, name = main&#125; + 14🍇 &lt;NSThread: 0x103007940&gt;&#123;number = 2, name = (null)&#125; + 9🍌 &lt;NSThread: 0x103103480&gt;&#123;number = 1, name = main&#125; + 15🍇 &lt;NSThread: 0x103007940&gt;&#123;number = 2, name = (null)&#125; + 10Program ended with exit code: 0 我们可以看到 ， 🍎代表的任务全部是优先执行的 ， 这说明sync添加的任务会阻塞当前线程 ， 在看到🍌和🍇是均匀分部的 。 这是由于async添加的任务会默认加入由系统管理的线程池 ， 异步执行 。 优先级 QoS当多个队列同时执行的时候 ， 系统需要知道哪个队列优先级更高 ， 才能优先安排计算资源给他 ， 我们可以这样定义优先级： 1let q = DispatchQueue(label: \"com.felix.felix\", qos: DispatchQoS.background) 初始化的时候加上qos参数 ， qos（quality of service）从字面上理解就是「服务质量」，在swift中是这样定义的： 12345678910111213141516171819202122232425public enum QoSClass &#123; @available(OSX 10.10, iOS 8.0, *) case background @available(OSX 10.10, iOS 8.0, *) case utility @available(OSX 10.10, iOS 8.0, *) case `default` @available(OSX 10.10, iOS 8.0, *) case userInitiated @available(OSX 10.10, iOS 8.0, *) case userInteractive case unspecified @available(OSX 10.10, iOS 8.0, *) public init?(rawValue: qos_class_t) @available(OSX 10.10, iOS 8.0, *) public var rawValue: qos_class_t &#123; get &#125; &#125; User Interactive： 和用户交互相关，比如动画等等优先级最高。比如用户连续拖拽的计算 User Initiated： 需要立刻的结果，比如push一个ViewController之前的数据计算 Utility： 可以执行很长时间，再通知用户结果。比如下载一个文件，给用户下载进度。 Background： 用户不可见，比如在后台存储大量数据 在选择时你要先思考一下几个问题 。 这个任务是用户可见的吗？ 这个任务和用户交互有关吗？ 这个任务的执行时间有多少？ 这个任务的最终结果和UI有关系吗？ 并发队列默认情况下添加进Queue的任务会串行执行 ， 先执行完一个再执行下一个： 1234567891011121314151617import Foundationlet q = DispatchQueue(label: \"com.felix.felix\")q.async &#123; (1...5).forEach(&#123; i in print(\"🍎 \\(Thread.current) + \\(i)\") &#125;)&#125;q.async &#123; (6...10).forEach(&#123; i in print(\"🍇 \\(Thread.current) + \\(i)\") &#125;)&#125;(11...15).forEach(&#123; i in print(\"🍌 \\(Thread.current) + \\(i)\")&#125;) 运行看下日志输出 123456789101112131415🍎 &lt;NSThread: 0x102a081a0&gt;&#123;number = 2, name = (null)&#125; + 1🍌 &lt;NSThread: 0x100f046f0&gt;&#123;number = 1, name = main&#125; + 11🍎 &lt;NSThread: 0x102a081a0&gt;&#123;number = 2, name = (null)&#125; + 2🍌 &lt;NSThread: 0x100f046f0&gt;&#123;number = 1, name = main&#125; + 12🍎 &lt;NSThread: 0x102a081a0&gt;&#123;number = 2, name = (null)&#125; + 3🍌 &lt;NSThread: 0x100f046f0&gt;&#123;number = 1, name = main&#125; + 13🍎 &lt;NSThread: 0x102a081a0&gt;&#123;number = 2, name = (null)&#125; + 4🍌 &lt;NSThread: 0x100f046f0&gt;&#123;number = 1, name = main&#125; + 14🍎 &lt;NSThread: 0x102a081a0&gt;&#123;number = 2, name = (null)&#125; + 5🍌 &lt;NSThread: 0x100f046f0&gt;&#123;number = 1, name = main&#125; + 15🍇 &lt;NSThread: 0x102a081a0&gt;&#123;number = 2, name = (null)&#125; + 6🍇 &lt;NSThread: 0x102a081a0&gt;&#123;number = 2, name = (null)&#125; + 7🍇 &lt;NSThread: 0x102a081a0&gt;&#123;number = 2, name = (null)&#125; + 8🍇 &lt;NSThread: 0x102a081a0&gt;&#123;number = 2, name = (null)&#125; + 9Program ended with exit code: 0 我们可以看到直到🍎都输出完毕才会输出🍇 ， 有时候我们想把任务并行执行 ， 怎么办呢 。这里我们可以设置queue的Attributes 。 1let q = DispatchQueue(label: \"com.felix.felix\", attributes: DispatchQueue.Attributes.concurrent) 再运行下 。 看看会怎样输出吧 . DispatchWorkItem有的时候 ， 对于同一个操作我们有可能会放在不同的线程中去执行 ， 这样我们就可以把这个操作用DispatchWorkItem的形式包裹起来 ， 在不同的线程中执行 。 1234567891011121314151617181920212223242526import Foundationlet group = DispatchGroup()let q = DispatchQueue(label: \"com.felix.felix\", attributes: DispatchQueue.Attributes.concurrent)let item1 = DispatchWorkItem &#123; (1...5).forEach(&#123; i in print(\"🍎 \\(Thread.current) + \\(i)\") &#125;)&#125;let item2 = DispatchWorkItem &#123; (6...10).forEach(&#123; i in print(\"🍇 \\(Thread.current) + \\(i)\") &#125;)&#125;q.async(execute: item1)q.async(execute: item2)(11...15).forEach(&#123; i in print(\"🍌 \\(Thread.current) + \\(i)\")&#125;) GroupDispatchGroup 可以用来管理一组队列 ， 监听所有队列的所有任务都完成的通知 ，比较常用的就是在一个页面请求多个接口的时候 ，全部请求完再刷新UI 。 pass 延时执行pass 线程安全pass 总结总之 ， 使用GCD一方面会提升我们应用的性能 ， 给用户带来更好的体验 ， 另一方面使用得当也能解决线程安全等问题 。","categories":[],"tags":[{"name":"swift","slug":"swift","permalink":"https://felixplusplus.github.io/tags/swift/"},{"name":"GCD","slug":"GCD","permalink":"https://felixplusplus.github.io/tags/GCD/"}]},{"title":"浅谈ObjC中load方法","slug":"load","date":"2018-06-10T03:27:09.000Z","updated":"2018-08-18T10:50:59.287Z","comments":true,"path":"2018/06/10/load/","link":"","permalink":"https://felixplusplus.github.io/2018/06/10/load/","excerpt":"","text":"在使用runtime进行 method swizz 的时候，我们一般是在load方法中进行方法交换 12345+ (void)load&#123; Method m = class_getInstanceMethod([self class], @selector(somemethod)); Method m0 = class_getInstanceMethod([self class], NSSelectorFromString(@\"somemethod\")); method_exchangeImplementations(m2, m1);&#125; 那么，这个load方法是如何执行的，是什么原理呢? 通过阅读runtime的源代码，我们可以看到这个顺序 load是在类被添加进runtime开始执行的 每个load方法只会执行一次 不会沿用父类的实现 每个类的父类先执行，然后是子类，最后是category分类 (递归) 没有[obj sendmsg]的那一套方法查找过程，直接获取函数指针执行 先就这么多了，欢迎补充","categories":[],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://felixplusplus.github.io/tags/Objective-C/"}]},{"title":"关于Objective-C的Property","slug":"property","date":"2018-06-04T12:53:32.000Z","updated":"2018-08-13T05:13:33.809Z","comments":true,"path":"2018/06/04/property/","link":"","permalink":"https://felixplusplus.github.io/2018/06/04/property/","excerpt":"","text":"一点关于Objective-C中合成存取器@property的总结在日常开发中，我们一般会使用 1@property (nonatomic,strong) Obj *obj 这样的表现形式来修饰当前对象的成员属性，大家都知道，相对于手工创建成员变量，@property等于变量加Getter&amp;Setter，那么先让我们看下日常的用法，一下为一些常用的关键字： atomic nonatomic readonly assign strong weak copy unsafe_unretained retain 下面分别简单介绍一下各个修饰符代表的意思 \batomic/nonatomicatoimc与nonatomic是对应的属性，其中，nonatomic表示非线程安全的，优点是内存开销小，相对而言的缺点是在多线程访问的过程中并不安全，但是atomic也不保证一定就会线程安全，为了保证属性访问\b的线程安全，我们需要对成员变量的读取加锁，这一节不对锁过多做介绍，日常中大部分的读取属性\b我们都是使用非线程安全的nonatomic。 readonly我们一般将property叫做\b合成存取器，因为它帮我们自动生成了getter&amp;setter方法，readonly则表示在自动生成存取方法的时候，不生成getter方法，也就是说在类对抗外部不能直接对类实例的该属性进行赋值操作，当我们不显式设定readonly的时候，合成存取则默认为readwrite，即外部可读可写。 assignassign常用于简单数据类型，含义为当前属性仅仅用于赋值操作，并不会持有该属性，亦不会增加该属性的引用计数，若该属性为对象类型则如果该属性销毁时并不会通知当前类对象，所以指针仍然指向之前的内存地址，这是调用get该属性时会导致野指针。 strongstrong从字面来理解就是【强】的意思，那么当property声明为strong时，表示该对象对该属性为强引用关系，会增加该成员属性的引用计数，所以该字段只能用于修饰对象类型而不能修饰基本类型。这样当自动释放池检查对象的饮用计数时，只要当前类对象未释放则该属性引用计数就不会为0。在该属性被赋值时会先增加新值的引用计数，再减少旧值的引用计数。 weakweak最常使用的场景时为标记该属性为代理，避免循环引用的时候，与strong恰恰相反，表示对该属性赋值时并不会增加其引用计数，也不会减少旧值的引用计数，属于‘虽然从当前对象能查看到这个对象，但是没啥关系’的那种。当该属性被销毁时property会自动置为nil，防止野指针。 copycopy常用语修饰block与字符串，由copy修饰的对象复制操作时会从内存空间拷贝一份，注意，不要用copy修饰可变类型如NSMutableArray等。 unsafe_unretained大部分同assign，不同在于unsafe_unretained仅可用来修饰基本数据类型 retain大部分同strong，由于再arc下辣鸡自动回收，所以不怎么使用该修饰。在MRC下基本等同与strong。","categories":[],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://felixplusplus.github.io/tags/Objective-C/"}]},{"title":"KVO","slug":"kvo","date":"2018-03-14T03:08:57.000Z","updated":"2018-08-18T10:50:41.358Z","comments":true,"path":"2018/03/14/kvo/","link":"","permalink":"https://felixplusplus.github.io/2018/03/14/kvo/","excerpt":"","text":"键值监听KVO先上结论： 当观察某对象 A 时，KVO 机制动态创建一个对象A当前类的子类，并为这个新的子类重写了被观察属性 keyPath 的 setter 方法。setter 方法随后负责通知观察对象属性的改变状况。 深入剖析： Apple 使用了 isa 混写（isa-swizzling）来实现 KVO 。当观察对象A时，KVO机制动态创建一个新的名为：NSKVONotifying_A 的新类，该类继承自对象A的本类，且 KVO 为 NSKVONotifying_A 重写观察属性的 setter 方法，setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象属性值的更改情况。（备注： isa 混写（isa-swizzling）isa：is a kind of ； swizzling：混合，搅合；） ①NSKVONotifying_A 类剖析：在这个过程，被观察对象的 isa 指针从指向原来的 A 类，被 KVO 机制修改为指向系统新创建的子类 NSKVONotifying_A 类，来实现当前类属性值改变的监听所以当我们从应用层面上看来，完全没有意识到有新的类出现，这是系统“隐瞒”了对 KVO 的底层实现过程，让我们误以为还是原来的类。但是此时如果我们创建一个新的名为“NSKVONotifying_A”的类，就会发现系统运行到注册 KVO 的那段代码时程序就崩溃，因为系统在注册监听的时候动态创建了名为 NSKVONotifying_A 的中间类，并指向这个中间类了。 （isa 指针的作用：每个对象都有 isa 指针，指向该对象的类，它告诉 Runtime 系统这个对象的类是什么。所以对象注册为观察者时，isa 指针指向新子类，那么这个被观察的对象就神奇地变成新子类的对象（或实例）了。） 因而在该对象上对 setter 的调用就会调用已重写的 setter，从而激活键值通知机制。—&gt;我猜，这也是 KVO 回调机制，为什么都俗称KVO技术为黑魔法的原因之一吧：内部神秘、外观简洁。 ②子类setter方法剖析：KVO 的键值观察通知依赖于 NSObject 的两个方法:willChangeValueForKey:和 didChangevlueForKey:在存取数值的前后分别调用 2 个方法：被观察属性发生改变之前，willChangeValueForKey:被调用，通知系统该 keyPath 的属性值即将变更；当改变发生后， didChangeValueForKey: 被调用，通知系统该 keyPath 的属性值已经变更；之后， observeValueForKey:ofObject:change:context: 也会被调用。且重写观察属性的 setter 方法这种继承方式的注入是在运行时而不是编译时实现的。 特点： 观察者观察的是属性，只有遵循 KVO 变更属性值的方式才会执行 KVO 的回调方法，例如是否执行了 setter 方法、或者是否使用了 KVC 赋值。如果赋值没有通过 setter 方法或者 KVC，而是直接修改属性对应的成员变量，例如：仅调用 _name = @”newName”，这时是不会触发 KVO 机制，更加不会调用回调方法的。所以使用 KVO 机制的前提是遵循 KVO 的属性设置方式来变更属性值。 使用：首先 ， 打开Xcode创建一个commandlineTool的工程 ， 让我们创建一个Person类 ， 并为其实现observe方法 1234567891011121314151617181920#import &lt;Foundation/Foundation.h&gt;@interface Person : NSObject@property (nonatomic , copy) NSString *name;@end#import \"Person.h\"@implementation Person- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123; id old = [change objectForKey:NSKeyValueChangeOldKey]; id new = [change objectForKey:NSKeyValueChangeNewKey]; NSLog(@\"I am %@\",self.name); NSLog(@\"I observe he change his name from %@ to %@\",old,new);&#125;@end 打开main.m 12345678910111213141516171819202122#import &lt;Foundation/Foundation.h&gt;#import \"Person.h\"int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // insert code here... Person *alice = [Person new]; alice.name = @\"alice\"; Person *alex = [Person new]; alex.name = @\"alex\"; [alex addObserver:alice forKeyPath:@\"name\" options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:nil]; alex.name = @\"alex.喜马拉雅.铁山\"; alex.name = @\"西门吹牛\"; alex.name = @\"关谷\"; [alex removeObserver:alice forKeyPath:@\"name\"]; alex.name = @\"欧阳\"; &#125; return 0;&#125; 解释一下上面的代码 创建两个Person的实例 ， alice和alex 将alice设置为alex的name属性的观察者 选项为观察新值和旧值 更改alex的name 删除观察者 再次更改alex的name 我们按下command+R 运行一下可以看到以下输出 1234567Test[82281:3097986] I am aliceTest[82281:3097986] I observe he change his name from alex to alex.喜马拉雅.铁山Test[82281:3097986] I am aliceTest[82281:3097986] I observe he change his name from alex.喜马拉雅.铁山 to 西门吹牛Test[82281:3097986] I am aliceTest[82281:3097986] I observe he change his name from 西门吹牛 to 关谷Program ended with exit code: 0 可以到KVO的使用还是非常方便的 ， 不过要注意使用完之后要移除观察者哦 。","categories":[],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://felixplusplus.github.io/tags/Objective-C/"},{"name":"KVO","slug":"KVO","permalink":"https://felixplusplus.github.io/tags/KVO/"}]},{"title":"我所了解的KVC","slug":"kvc","date":"2018-02-12T03:08:54.000Z","updated":"2018-08-18T10:50:28.900Z","comments":true,"path":"2018/02/12/kvc/","link":"","permalink":"https://felixplusplus.github.io/2018/02/12/kvc/","excerpt":"","text":"先介绍下KVC（Key-value coding）键值编码，从名字大概可以推断出功能，也就是根据对象的属性名称这个‘key‘来设置和操作’value‘，好，那么让我们先上手试一下。 打开Xcode，选择新建工程，选择macos，然后选择commandline。 新建学生类 12345@interface Student : NSObject@property (nonatomic, copy) NSString *name;@end 找到main.m 123456789101112131415#import &lt;Foundation/Foundation.h&gt;#import \"Student.h\"int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // insert code here... Student *s = [Student new]; [s setValue:@\"zhangsan\" forKey:@\"name\"]; NSLog(@\"%@\", [s valueForKey:@\"name\"]); &#125; return 0;&#125; 神奇吧 ，我们仅仅是根据一个字符串 ，就完成了对student-&gt;name的赋值操作 ！这是否让你联想到什么呢 ，仔细思考 。。。没错 ，当我们从服务端拉取数据的时候 ， 往往是一串json，我们把它转化成为字典或数组等形式，但是我们不想在接下来的调用中没完没了的使用字典，所以我们要把它转化为model ！ 作用介绍 动态地取值和设值 访问和修改私有变量 Model和字典转换 动态存值由于我们不用显示的调用getset方法操作对象的属性 ， 所以我们可以很方便的通过key为字符串的形式对model进行赋值 访问和修改私有变量有些三方库的私有属性我们需要做一些调整改变 ， 但是私有属性无法在外部直接访问 ， 这时我们就可以直接在外部进行key-value赋值 Model和字典转换客户端经常要发起网络请求 ， 当服务端反给我们response的时候先解析成Dictionary ， 不过在代码中直接使用dictionary进行操作 ， 修改视图等操作既不安全 ， 写起来也很烦 。除了使用第三方model-dic解析框架外也可以自己实现一个基于KVC的dictionary解析helper 。 日常中使用的KVC就是以上几个方面的了 ， 欢迎补充 。","categories":[],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://felixplusplus.github.io/tags/Objective-C/"},{"name":"KVC","slug":"KVC","permalink":"https://felixplusplus.github.io/tags/KVC/"}]},{"title":"MVVM实践","slug":"mvvm","date":"2018-01-22T09:08:44.000Z","updated":"2018-08-18T10:51:47.910Z","comments":true,"path":"2018/01/22/mvvm/","link":"","permalink":"https://felixplusplus.github.io/2018/01/22/mvvm/","excerpt":"","text":"一点对MVVM微不足道的总结目前客户端最流行的架构应该就是MVVM ， 然而看了一大堆博客之后 ， 大部分是大谈特谈而并没有仔细讲解具体的可行之法 ， 这篇博客将会说说我在实际工作中的使用 。 基本概念MVC MVC模式（Model–view–controller）是软件工程中的一种软件架构模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。MVC模式最早由Trygve Reenskaug在1978年提出[1]，是施乐帕罗奥多研究中心（Xerox PARC）在20世纪80年代为程序语言Smalltalk发明的一种软件架构。MVC模式的目的是实现一种动态的程序设计，使后续对程序的修改和扩展简化，并且使程序某一部分的重复利用成为可能。除此之外，此模式通过对复杂度的简化，使程序结构更加直观。软件系统通过对自身基本部分分离的同时也赋予了各个基本部分应有的功能。专业人员可以通过自身的专长分组： 控制器（Controller）- 负责转发请求，对请求进行处理。 视图（View） - 界面设计人员进行图形界面设计。 模型（Model） - 程序员编写程序应有的功能（实现算法等等）、数据库专家进行数据管理和数据库设计(可以实现具体的功能)。 MVVM MVVM是Model-View-ViewModel的简写，最早是由微软公司提出并运用，是MVP（Model-View-Presenter）模式与WPF结合的应用方式时发展演变过来的一种新型架构架构。 MVVM有助于将图形用户界面的开发与业务逻辑或后端逻辑（数据模型）的开发分离开来，这是通过置标语言或GUI代码实现的。MVVM的视图模型是一个值转换器， 这意味着视图模型负责从模型中暴露（转换）数据对象，以便轻松管理和呈现对象。在这方面，视图模型比视图做得更多，并且处理大部分视图的显示逻辑。 视图模型可以实现中介者模式，组织对视图所支持的用例集的后端逻辑的访问。 模型 模型是指代表真实状态内容的领域模型（面向对象），或指代表内容的数据访问层（以数据为中心）。 视图 就像在MVC和MVP模式中一样，视图是用户在屏幕上看到的结构、布局和外观（UI）。 视图模型 视图模型是暴露公共属性和命令的视图的抽象。MVVM没有MVC模式的控制器，也没有MVP模式的presenter，有的是一个绑定器。在视图模型中，绑定器在视图和数据绑定器之间进行通信。 绑定器 声明性数据和命令绑定隐含在MVVM模式中。在Microsoft解决方案堆中，绑定器是一种名为XAML的标记语言。绑定器使开发人员免于被迫编写样板式逻辑来同步视图模型和视图。在微软的堆之外实现时，声明性数据绑定技术的出现是实现该模式的一个关键因素。 优点解决controller过于臃肿在MVC中很容易就会把一些业务逻辑 ， 网络请求 ， 数据IO都放在controller中 注意 ， 这里不是说MVC的控制器一定很臃肿 ， 而是「容易变得臃肿」 在我们新建一个工程的时候 ， 苹果会自动帮我们生成一个ViewController ， 而在动手开始写代码的时候 ， 往往控制不住就直接将逻辑写在Controller中 。 MVVM架构会要求我们把任何与非View的逻辑玻璃出来 ， Controller中除了绑定viewModel之外的代码只允许出现对View的操作 。 因为Controller对我们来说也只是一个View 。 逻辑分离就像上面说的 ， 业务逻辑都会抽离出来放在viewModel中 ，这样可以在任何地方重用这一堆业务 除此之外 ， 我们的代码将会更加易于测试 ， 避免出现在MVC中可能出现的那种超长的方法、严重依赖全局状态导致难以测试的问题 。 view重用 (可拥有view单独的viewModel)在MVVM中 ， View只需要与ViewMode交互 ， 不会收到其他的影响 ， 所以不但vm、m 可以重用 ， view一样可以重复使用 ， 修改的时候也更加方便 。 缺点BUG与传递由于在MVVM里面View和ViewModel是松耦合的 ， 在测试出问题的时候就要排查各个地方的问题 ， 有可能是vm中的也有可能是view中的 。 由于vm会传递数据 ， 一个bug会很容易的传递到其他地方， 引发更大的问题。 并且其中一个地方出现问题的话 ， 这个BUG就极有可能随着传递到其他的逻辑中 ， 从而导致更严重的问题发生 。 需要维护Model ， viewModel ， 和view的开销 ， 内存花费大额外的viewModel使用也并不是无代价的 ， 有可能由于各种原因导致内存占用增多 ， 而额外的 ， 如果因为强饮用或其他原因导致的循环引用等内存不能正确释放的情况下 ， 有可能会内存疯涨 。 使用方法上面说了这些只是一个大致的介绍 ， 我们还是来看看应该怎样使用吧 。 你可以使用delegate的方式或者block的方式对view和viewModel进行桥接 ， 在这里我们选择使用delegate ， 我认为这样看着比较直观 ， 在代码中也更加明确。 首先创建一个工程 ， 选择singleViewApplication ， 我们就以最常见的的登陆功能作为示例 新建用于由viewModel调用 ， view进行响应的protocol首先要起个名字 ， 就叫LoginViewModelDelegateProtocol 吧 123@protocol LoginViewModelDelegateProtocol &lt;NSObject&gt;@end 好 ， 让我们想一想view会发送一些什么数据给VM ，VM都需要什么数据 。 对于简单登陆的VM来说 ， 我们需要通知view的数据和方法 登陆成功 错误提示 按钮状态改变（是否可以点击） 那么我们可以在protocol中添加方法了 1234567@protocol LoginViewModelDelegateProtocol &lt;NSObject&gt;- (void)loginSuccess;- (void)showTips:(NSString *)tip;- (void)buttonEnable:(BOOL )enable;@end 新建用于由view调用 ， viewModel进行响应的protocol同理 ， 我们只要确认vm和v需要交换的数据就好了 。 用户名输入框的字符串 密码输入框的字符串 点击登陆事件 1234567@protocol LoginViewModelInterfaceProtocol &lt;NSObject&gt;- (void)inputUserName:(NSString *)uname;- (void)inputPwd:(NSString *)pwd;- (void)didTapLoginBUtton;@end 实现代理方法下面我们新建一个viewModel叫做LoginViewModel LoginViewModel.h 123456789#import &lt;Foundation/Foundation.h&gt;#import \"LoginViewModelDelegateProtocol.h\"#import \"LoginViewModelInterfaceProtocol.h\"@interface LoginViewModel : NSObject&lt;LoginViewModelInterfaceProtocol&gt;@property (nonatomic ,weak) id&lt;LoginViewModelDelegateProtocol&gt; delegate;@end LoginViewModel.m 1234567891011121314151617181920212223242526272829303132333435#import \"LoginViewModelDelegateProtocol.h\"@interface LoginViewModel ()@property (assign, nonatomic) BOOL unameValid;@property (assign, nonatomic) BOOL pwdValid;@end@implementation LoginViewModel- (void)inputUserName:(NSString *)uname &#123; self.unameValid = uname.length&gt;0; [self judgeAllValid];&#125;- (void)inputPwd:(NSString *)pwd &#123; self.pwdValid = pwd.length&gt;0; [self judgeAllValid];&#125;- (void)didTapLoginBUtton &#123; // 一些请求 ， 这里忽略网络请求 ， 直接模拟结果 [self.delegate loginSuccess];&#125;- (void)judgeAllValid &#123; BOOL v = [self isAllValid]; [self.delegate buttonEnable:v];&#125;- (BOOL)isAllValid &#123; return self.unameValid &amp;&amp; self.pwdValid;&#125;@end 然后在controller初始化 ， 并且实现全部的方法就可以了 。 viewController.m 123456789101112131415161718192021222324252627282930313233343536#import \"viewController.h\"...@interface viewController () &lt;LoginViewModelDelegateProtocol&gt;@property (nonatomic ,strong) LoginViewModel *vm;@end@implementation TDFSetPhoneNumController- (void)viewDidLoad &#123; [super viewDidLoad]; self.vm.delegate = self;&#125;#pragma mark - VMDelegate- (void)loginSuccess &#123; [self.navigationController pushViewController:[SuccessVC new]] animated:true];&#125;- (void)showTips:(NSString *)tip &#123; [self showAlert:tip];&#125;- (void)buttonEnable:(BOOL )enable &#123; self.loginbutton.enable = enable;&#125;#pragma mark - Getter- (LoginViewModel *)vm &#123; if (!_vm) &#123; _vm = [LoginViewModel new]; &#125; return _vm;&#125;@end 大功告成这里全部的代码是我手写的 ， 后面省略了一些UIKit相关的布局 ， 想必以你的聪明才智应该已经能很轻松的将剩余的补全了吧 。 注意事项这里有几点我认为应该注意的 vm与v之间不论通过什么传递值和响应 ， 都要保持数据的单向流动 。 代理用weak ， 内存回收时会自动置为nil ， 全部model与viewModel中不应包含任何UIKit框架下的类 总结总而言之 ， 我认为MVVM在我们的代码整体分工和应用架构的过程中应用还是十分优雅和安全的 ， 不过话说回来什么架构也罢 ， 还是要看我们怎么去用它 ， 不是吗","categories":[],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"https://felixplusplus.github.io/tags/Objective-C/"},{"name":"MVVM","slug":"MVVM","permalink":"https://felixplusplus.github.io/tags/MVVM/"}]}]}